{"ast":null,"code":"/*!\n * node-sass: lib/extensions.js\n */\nvar eol = require('os').EOL,\n    fs = require('fs'),\n    pkg = require('../package.json'),\n    mkdir = require('mkdirp'),\n    path = require('path'),\n    defaultBinaryDir = path.join(__dirname, '..', 'vendor'),\n    trueCasePathSync = require('true-case-path');\n/**\n * Get the human readable name of the Platform that is running\n *\n * @param  {string} platform - An OS platform to match, or null to fallback to\n * the current process platform\n * @return {Object} The name of the platform if matched, false otherwise\n *\n * @api public\n */\n\n\nfunction getHumanPlatform(platform) {\n  switch (platform || process.platform) {\n    case 'darwin':\n      return 'OS X';\n\n    case 'freebsd':\n      return 'FreeBSD';\n\n    case 'linux':\n      return 'Linux';\n\n    case 'linux_musl':\n      return 'Linux/musl';\n\n    case 'win32':\n      return 'Windows';\n\n    default:\n      return false;\n  }\n}\n/**\n * Provides a more readable version of the architecture\n *\n * @param  {string} arch - An instruction architecture name to match, or null to\n * lookup the current process architecture\n * @return {Object} The value of the process architecture, or false if unknown\n *\n * @api public\n */\n\n\nfunction getHumanArchitecture(arch) {\n  switch (arch || process.arch) {\n    case 'ia32':\n      return '32-bit';\n\n    case 'x86':\n      return '32-bit';\n\n    case 'x64':\n      return '64-bit';\n\n    default:\n      return false;\n  }\n}\n/**\n * Get the friendly name of the Node environment being run\n *\n * @param  {Object} abi - A Node Application Binary Interface value, or null to\n * fallback to the current Node ABI\n * @return {Object} Returns a string name of the Node environment or false if\n * unmatched\n *\n * @api public\n */\n\n\nfunction getHumanNodeVersion(abi) {\n  switch (parseInt(abi || process.versions.modules, 10)) {\n    case 11:\n      return 'Node 0.10.x';\n\n    case 14:\n      return 'Node 0.12.x';\n\n    case 42:\n      return 'io.js 1.x';\n\n    case 43:\n      return 'io.js 1.1.x';\n\n    case 44:\n      return 'io.js 2.x';\n\n    case 45:\n      return 'io.js 3.x';\n\n    case 46:\n      return 'Node.js 4.x';\n\n    case 47:\n      return 'Node.js 5.x';\n\n    case 48:\n      return 'Node.js 6.x';\n\n    case 49:\n      return 'Electron 1.3.x';\n\n    case 50:\n      return 'Electron 1.4.x';\n\n    case 51:\n      return 'Node.js 7.x';\n\n    case 53:\n      return 'Electron 1.6.x';\n\n    case 57:\n      return 'Node.js 8.x';\n\n    case 59:\n      return 'Node.js 9.x';\n\n    case 64:\n      return 'Node.js 10.x';\n\n    case 67:\n      return 'Node.js 11.x';\n\n    case 72:\n      return 'Node.js 12.x';\n\n    default:\n      return false;\n  }\n}\n/**\n * Get a human readable description of where node-sass is running to support\n * user error reporting when something goes wrong\n *\n * @param  {string} env - The name of the native bindings that is to be parsed\n * @return {string} A description of what os, architecture, and Node version\n * that is being run\n *\n * @api public\n */\n\n\nfunction getHumanEnvironment(env) {\n  var binding = env.replace(/_binding\\.node$/, ''),\n      parts = binding.split('-'),\n      platform = getHumanPlatform(parts[0]),\n      arch = getHumanArchitecture(parts[1]),\n      runtime = getHumanNodeVersion(parts[2]);\n\n  if (parts.length !== 3) {\n    return 'Unknown environment (' + binding + ')';\n  }\n\n  if (!platform) {\n    platform = 'Unsupported platform (' + parts[0] + ')';\n  }\n\n  if (!arch) {\n    arch = 'Unsupported architecture (' + parts[1] + ')';\n  }\n\n  if (!runtime) {\n    runtime = 'Unsupported runtime (' + parts[2] + ')';\n  }\n\n  return [platform, arch, 'with', runtime].join(' ');\n}\n/**\n * Get the value of the binaries under the default path\n *\n * @return {Array} The currently installed node-sass bindings\n *\n * @api public\n */\n\n\nfunction getInstalledBinaries() {\n  return fs.readdirSync(getBinaryDir());\n}\n/**\n * Check that an environment matches the whitelisted values or the current\n * environment if no parameters are passed\n *\n * @param  {string} platform - The name of the OS platform(darwin, win32, etc...)\n * @param  {string} arch - The instruction set architecture of the Node environment\n * @param  {string} abi - The Node Application Binary Interface\n * @return {Boolean} True, if node-sass supports the current platform, false otherwise\n *\n * @api public\n */\n\n\nfunction isSupportedEnvironment(platform, arch, abi) {\n  return false !== getHumanPlatform(platform) && false !== getHumanArchitecture(arch) && false !== getHumanNodeVersion(abi);\n}\n/**\n * Get the value of a CLI argument\n *\n * @param {String} name\n * @param {Array} args\n * @api private\n */\n\n\nfunction getArgument(name, args) {\n  var flags = args || process.argv.slice(2),\n      index = flags.lastIndexOf(name);\n\n  if (index === -1 || index + 1 >= flags.length) {\n    return null;\n  }\n\n  return flags[index + 1];\n}\n/**\n * Get binary name.\n * If environment variable SASS_BINARY_NAME,\n * .npmrc variable sass_binary_name or\n * process argument --binary-name is provided,\n * return it as is, otherwise make default binary\n * name: {platform}-{arch}-{v8 version}.node\n *\n * @api public\n */\n\n\nfunction getBinaryName() {\n  var binaryName,\n      variant,\n      platform = process.platform;\n\n  if (getArgument('--sass-binary-name')) {\n    binaryName = getArgument('--sass-binary-name');\n  } else if (process.env.SASS_BINARY_NAME) {\n    binaryName = process.env.SASS_BINARY_NAME;\n  } else if (process.env.npm_config_sass_binary_name) {\n    binaryName = process.env.npm_config_sass_binary_name;\n  } else if (pkg.nodeSassConfig && pkg.nodeSassConfig.binaryName) {\n    binaryName = pkg.nodeSassConfig.binaryName;\n  } else {\n    variant = getPlatformVariant();\n\n    if (variant) {\n      platform += '_' + variant;\n    }\n\n    binaryName = [platform, '-', process.arch, '-', process.versions.modules].join('');\n  }\n\n  return [binaryName, 'binding.node'].join('_');\n}\n/**\n * Determine the URL to fetch binary file from.\n * By default fetch from the node-sass distribution\n * site on GitHub.\n *\n * The default URL can be overriden using\n * the environment variable SASS_BINARY_SITE,\n * .npmrc variable sass_binary_site or\n * or a command line option --sass-binary-site:\n *\n *   node scripts/install.js --sass-binary-site http://example.com/\n *\n * The URL should to the mirror of the repository\n * laid out as follows:\n *\n * SASS_BINARY_SITE/\n *\n *  v3.0.0\n *  v3.0.0/freebsd-x64-14_binding.node\n *  ....\n *  v3.0.0\n *  v3.0.0/freebsd-ia32-11_binding.node\n *  v3.0.0/freebsd-x64-42_binding.node\n *  ... etc. for all supported versions and platforms\n *\n * @api public\n */\n\n\nfunction getBinaryUrl() {\n  var site = getArgument('--sass-binary-site') || process.env.SASS_BINARY_SITE || process.env.npm_config_sass_binary_site || pkg.nodeSassConfig && pkg.nodeSassConfig.binarySite || 'https://github.com/sass/node-sass/releases/download';\n  return [site, 'v' + pkg.version, getBinaryName()].join('/');\n}\n/**\n * Get binary dir.\n * If environment variable SASS_BINARY_DIR,\n * .npmrc variable sass_binary_dir or\n * process argument --sass-binary-dir is provided,\n * select it by appending binary name, otherwise\n * use default binary dir.\n * Once the primary selection is made, check if\n * callers wants to throw if file not exists before\n * returning.\n *\n * @api public\n */\n\n\nfunction getBinaryDir() {\n  var binaryDir;\n\n  if (getArgument('--sass-binary-dir')) {\n    binaryDir = getArgument('--sass-binary-dir');\n  } else if (process.env.SASS_BINARY_DIR) {\n    binaryDir = process.env.SASS_BINARY_DIR;\n  } else if (process.env.npm_config_sass_binary_dir) {\n    binaryDir = process.env.npm_config_sass_binary_dir;\n  } else if (pkg.nodeSassConfig && pkg.nodeSassConfig.binaryDir) {\n    binaryDir = pkg.nodeSassConfig.binaryDir;\n  } else {\n    binaryDir = defaultBinaryDir;\n  }\n\n  return binaryDir;\n}\n/**\n * Get binary path.\n * If environment variable SASS_BINARY_PATH,\n * .npmrc variable sass_binary_path or\n * process argument --sass-binary-path is provided,\n * select it by appending binary name, otherwise\n * make default binary path using binary name.\n * Once the primary selection is made, check if\n * callers wants to throw if file not exists before\n * returning.\n *\n * @api public\n */\n\n\nfunction getBinaryPath() {\n  var binaryPath;\n\n  if (getArgument('--sass-binary-path')) {\n    binaryPath = getArgument('--sass-binary-path');\n  } else if (process.env.SASS_BINARY_PATH) {\n    binaryPath = process.env.SASS_BINARY_PATH;\n  } else if (process.env.npm_config_sass_binary_path) {\n    binaryPath = process.env.npm_config_sass_binary_path;\n  } else if (pkg.nodeSassConfig && pkg.nodeSassConfig.binaryPath) {\n    binaryPath = pkg.nodeSassConfig.binaryPath;\n  } else {\n    binaryPath = path.join(getBinaryDir(), getBinaryName().replace(/_(?=binding\\.node)/, '/'));\n  }\n\n  if (process.versions.modules < 46) {\n    return binaryPath;\n  }\n\n  try {\n    return trueCasePathSync(binaryPath) || binaryPath;\n  } catch (e) {\n    return binaryPath;\n  }\n}\n/**\n * An array of paths suitable for use as a local disk cache of the binding.\n *\n * @return {[]String} an array of paths\n * @api public\n */\n\n\nfunction getCachePathCandidates() {\n  return [process.env.npm_config_sass_binary_cache, process.env.npm_config_cache].filter(function (_) {\n    return _;\n  });\n}\n/**\n * The most suitable location for caching the binding on disk.\n *\n * Given the candidates directories provided by `getCachePathCandidates()` this\n * returns the first writable directory. By treating the candidate directories\n * as a prioritised list this method is deterministic, assuming no change to the\n * local environment.\n *\n * @return {String} directory to cache binding\n * @api public\n */\n\n\nfunction getBinaryCachePath() {\n  var i,\n      cachePath,\n      cachePathCandidates = getCachePathCandidates();\n\n  for (i = 0; i < cachePathCandidates.length; i++) {\n    cachePath = path.join(cachePathCandidates[i], pkg.name, pkg.version);\n\n    try {\n      mkdir.sync(cachePath);\n      return cachePath;\n    } catch (e) {// Directory is not writable, try another\n    }\n  }\n\n  return '';\n}\n/**\n * The cached binding\n *\n * Check the candidates directories provided by `getCachePathCandidates()` for\n * the binding file, if it exists. By treating the candidate directories\n * as a prioritised list this method is deterministic, assuming no change to the\n * local environment.\n *\n * @return {String} path to cached binary\n * @api public\n */\n\n\nfunction getCachedBinary() {\n  var i,\n      cachePath,\n      cacheBinary,\n      cachePathCandidates = getCachePathCandidates(),\n      binaryName = getBinaryName();\n\n  for (i = 0; i < cachePathCandidates.length; i++) {\n    cachePath = path.join(cachePathCandidates[i], pkg.name, pkg.version);\n    cacheBinary = path.join(cachePath, binaryName);\n\n    if (fs.existsSync(cacheBinary)) {\n      return cacheBinary;\n    }\n  }\n\n  return '';\n}\n/**\n * Does the supplied binary path exist\n *\n * @param {String} binaryPath\n * @api public\n */\n\n\nfunction hasBinary(binaryPath) {\n  return fs.existsSync(binaryPath);\n}\n/**\n * Get Sass version information\n *\n * @api public\n */\n\n\nfunction getVersionInfo(binding) {\n  return [['node-sass', pkg.version, '(Wrapper)', '[JavaScript]'].join('\\t'), ['libsass  ', binding.libsassVersion(), '(Sass Compiler)', '[C/C++]'].join('\\t')].join(eol);\n}\n/**\n * Gets the platform variant, currently either an empty string or 'musl' for Linux/musl platforms.\n *\n * @api public\n */\n\n\nfunction getPlatformVariant() {\n  var contents = '';\n\n  if (process.platform !== 'linux') {\n    return '';\n  }\n\n  try {\n    contents = fs.readFileSync(process.execPath); // Buffer.indexOf was added in v1.5.0 so cast to string for old node\n    // Delay contents.toStrings because it's expensive\n\n    if (!contents.indexOf) {\n      contents = contents.toString();\n    }\n\n    if (contents.indexOf('libc.musl-x86_64.so.1') !== -1) {\n      return 'musl';\n    }\n  } catch (err) {} // eslint-disable-line no-empty\n\n\n  return '';\n}\n\nmodule.exports.hasBinary = hasBinary;\nmodule.exports.getBinaryUrl = getBinaryUrl;\nmodule.exports.getBinaryName = getBinaryName;\nmodule.exports.getBinaryDir = getBinaryDir;\nmodule.exports.getBinaryPath = getBinaryPath;\nmodule.exports.getBinaryCachePath = getBinaryCachePath;\nmodule.exports.getCachedBinary = getCachedBinary;\nmodule.exports.getCachePathCandidates = getCachePathCandidates;\nmodule.exports.getVersionInfo = getVersionInfo;\nmodule.exports.getHumanEnvironment = getHumanEnvironment;\nmodule.exports.getInstalledBinaries = getInstalledBinaries;\nmodule.exports.isSupportedEnvironment = isSupportedEnvironment;","map":null,"metadata":{},"sourceType":"script"}